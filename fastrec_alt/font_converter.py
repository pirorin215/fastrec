#!/usr/bin/env python3
"""
Custom Font Converter for 13x28 pixel fonts

Converts readable binary format to C array format for ESP32 display.

Usage:
    python3 font_converter.py <font_file.txt>

Input format (txt file):
    - 28 lines per character
    - 13 characters per line (0 or 1)
    - Separate characters with blank line
    - Lines starting with '#' are treated as comments

Output format:
    - C array: largeFont[N][56] PROGMEM
    - 28 rows Ã— 2 bytes per row
    - Saved to custom_font.h

Example input (13 pixels x 28 rows):
    # Character 0: Digit zero
    1111111111111
    1111111111111
    1100000000011
    ... (28 lines total)
    (blank line)
    # Character 1: Digit one
    1100000000000
    ...
"""

# Fixed configuration for 13x28 pixel fonts
PIXEL_WIDTH = 13
NUM_ROWS = 28

def bin_to_hex(bin_str):
    """Convert binary string to 2-byte hex format"""
    # Truncate or pad to PIXEL_WIDTH
    bin_str = bin_str[:PIXEL_WIDTH].ljust(PIXEL_WIDTH, '0')
    # Pad to 16 bits (2 bytes) by adding zeros on RIGHT
    # lcd_display.ino draws bits 15-3 (13 bits), so rightmost 3 bits (2-0) are not drawn
    # We need to shift left by 3 to ensure all PIXEL_WIDTH bits are in bits 15-3
    padded = bin_str + ("0" * 3)  # PIXEL_WIDTH + 3 = 16 bits total
    # Convert to integer
    value = int(padded, 2)
    # Split into 2 bytes (big-endian)
    byte1 = (value >> 8) & 0xFF
    byte2 = value & 0xFF
    return f"0x{byte1:02X},0x{byte2:02X}"

def parse_font_file(filepath):
    """Parse font definition file and return character data"""
    import sys

    with open(filepath, 'r') as f:
        content = f.read()

    # Remove comment lines first (lines starting with #)
    lines_without_comments = []
    for line in content.split('\n'):
        stripped = line.strip()
        # Keep non-comment lines (preserve empty lines for character separation)
        if stripped.startswith('#'):
            continue
        lines_without_comments.append(line)

    content = '\n'.join(lines_without_comments)

    # Split by blank lines to get individual characters
    char_blocks = content.strip().split('\n\n')

    characters = []
    for char_idx, block in enumerate(char_blocks):
        # Filter out empty lines
        lines = [line.strip() for line in block.strip().split('\n') if line.strip()]

        if len(lines) == 0:
            continue

        # Strict validation: NUM_ROWS lines per character
        if len(lines) != NUM_ROWS:
            print(f"\nERROR: Character {char_idx} has {len(lines)} lines (expected {NUM_ROWS})")
            print(f"Please edit the font file to have exactly {NUM_ROWS} lines per character.")
            print(f"Note: Comment lines (starting with '#') are not counted.")
            print(f"Current character {char_idx} preview:")
            for i, line in enumerate(lines[:5]):  # Show first 5 lines
                print(f"  Line {i}: {line}")
            if len(lines) > 5:
                print(f"  ... ({len(lines) - 5} more lines)")
            sys.exit(1)

        # Strict validation: PIXEL_WIDTH per line
        validated_lines = []
        for line_idx, line in enumerate(lines):
            # Remove any '0x' prefix and non-binary chars
            clean = line.replace('0x', '').replace(',', '').strip()
            clean = ''.join(c for c in clean if c in '01')

            if len(clean) != PIXEL_WIDTH:
                print(f"\nERROR: Character {char_idx}, Line {line_idx} has {len(clean)} pixels (expected {PIXEL_WIDTH})")
                print(f"Line content: {line}")
                print(f"Cleaned content: {clean}")
                print(f"Please edit the font file to have exactly {PIXEL_WIDTH} characters per line.")
                sys.exit(1)

            validated_lines.append(clean)

        characters.append(validated_lines)

    return characters

def generate_c_array(characters):
    """Generate C array code from character data"""
    num_bytes = NUM_ROWS * 2  # 2 bytes per row
    output = []
    output.append(f"// Custom large font for time display ({PIXEL_WIDTH}x{NUM_ROWS} pixels)")
    output.append("// Generated by font_converter.py")
    output.append(f"// Each character is {PIXEL_WIDTH} pixels wide, {NUM_ROWS} pixels tall")
    output.append(f"// Stored as {NUM_ROWS} rows, 2 bytes per row")
    output.append("const uint8_t largeFont[" + str(len(characters)) + "][" + str(num_bytes) + "] PROGMEM = {")

    for char_idx, char in enumerate(characters):
        output.append(f"  {{ // Character {char_idx}")

        # Convert each row to hex format
        hex_rows = []
        for row in char:
            hex_rows.append(bin_to_hex(row))

        # Split into groups of 4 rows per line for readability
        for i in range(0, len(hex_rows), 4):
            group = hex_rows[i:i+4]
            line = "   " + ", ".join(group)
            if i + 4 < len(hex_rows):
                line += ","
            else:
                line += ","
            output.append(line)

        output.append(" }," if char_idx < len(characters) - 1 else " }")

    output.append("};")
    return "\n".join(output)

def main():
    import sys

    if len(sys.argv) < 2:
        print("Usage:")
        print("  python3 font_converter.py <font_file.txt>")
        print("\nInput file format:")
        print(f"  - {NUM_ROWS} lines per character")
        print(f"  - {PIXEL_WIDTH} characters per line (0 or 1)")
        print("  - Separate characters with blank line")
        print("  - Lines starting with '#' are treated as comments")
        print("\nOutput:")
        print("  - C array saved to custom_font.h")
        print(f"  - Format: largeFont[N][{NUM_ROWS * 2}] PROGMEM")
        print("\nExample:")
        print(f"  python3 font_converter.py custom_font_13.txt")
        print("\nExample input (13 pixels x 28 rows):")
        print("  # Character 0: Digit zero")
        print("  1111111111111")
        print("  1111111111111")
        print("  1100000000011")
        print(f"  ... ({NUM_ROWS} lines total)")
        print("  (blank line)")
        print("  # Character 1: Digit one")
        print("  1100000000000")
        print("  ...")
        sys.exit(1)

    input_file = sys.argv[1]

    print(f"Converting {input_file} ({PIXEL_WIDTH}x{NUM_ROWS} pixels)...")

    # Parse font file
    characters = parse_font_file(input_file)
    print(f"Found {len(characters)} characters")

    # Generate C array
    c_code = generate_c_array(characters)

    # Output
    print("\n" + "="*60)
    print(f"Generated C Array ({PIXEL_WIDTH}x{NUM_ROWS}):")
    print("="*60)
    print(c_code)
    print("="*60)

    # Save to file
    output_file = "custom_font.h"
    with open(output_file, 'w') as f:
        f.write(c_code)
    print(f"\nSaved to: {output_file}")

if __name__ == "__main__":
    main()
